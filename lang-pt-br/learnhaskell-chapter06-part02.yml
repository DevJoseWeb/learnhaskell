title: Some higher-orderism is in order

text: Functions can take functions as parameters and also return functions. To illustrate this, we're going to make a function that takes a function and then applies it twice to something!



First of all, notice the type declaration. Before, we didn't need parentheses because <span class="fixed">-&gt;</span> is naturally right-associative. However, here, they're mandatory. They indicate that the first parameter is a function that takes something and returns that same thing. The second parameter is something of that type also and the return value is also of the same type. We could read this type declaration in the curried way, but to save ourselves a headache, we'll just say that this function takes two parameters and returns one thing. The first parameter is a function (of type <span class="fixed">a -&gt; a</span>) and the second is that same <span class="fixed">a</span>. The function can also be <span class="fixed">Int -&gt; Int</span> or <span class="fixed">String -&gt; String</span> or whatever. But then, the second parameter to also has to be of that type. 

Nota: From now on, we'll say that functions take several parameters despite each function actually taking only one parameter and returning partially applied functions until we reach a function that returns a solid value. So for simplicty's sake, we'll say that <span class="fixed">a -&gt; a -&gt; a</span> takes two parameters, even though we know what's really going on under the hood.

The body of the function is pretty simple. We just use the parameter <span class="fixed">f</span> as a function, applying <span class="fixed">x</span> to it by separating them with a space and then applying the result to <span class="fixed">f</span> again. Anyway, playing around with the function:



The awesomeness and usefulness of partial application is evident. If our function requires us to pass it a function that takes only one parameter, we can just partially apply a function to the point where it takes only one parameter and then pass it.

Now we're going to use higher order programming to implement a really useful function that's in the standard library. It's called <span class="fixed">zipWith</span>. It takes a function and two lists and parameters and then joins the two lists by applying the function between corresponding elements. Here's how we'll implement it:



Look at the type declaration. The first parameter is a function that takes two things and produces a third thing. They don't have to be of the same type, but they can. The second and third parameter are lists. The result is also a list. The second has to be a list of <span class="fixed">a</span>'s, because the joining function takes <span class="fixed">a</span>'s as its first argument. The second has to be a list of <span class="fixed">b</span>'s, because the second argument to the joining function is of type <span class="fixed">b</span>. The result is a list of <span class="fixed">c</span>'s. If the type declaration of a function says it accepts an <span class="fixed">a -&gt; b -&gt; c</span> function as a parameter, it will also accept an <span class="fixed">a -&gt; a -&gt; a</span> function, but not the other way around! Remember that when you're making functions, especially higher order ones, and you're unsure of the type, you can just try omitting the type declaration and then checking what Haskell infers it to be by using <span class="fixed">t:</span>.

The action in the function is pretty similar to the normal <span class="fixed">zip</span>. The edge conditions are the same, only there's an extra argument, the joining function, but that argument doesn't matter in the edge conditions, so we just use a <span class="fixed">_</span> for it. And function body at the last pattern is also similar to <span class="fixed">zip</span>, only it doesn't do <span class="fixed">(x,y)</span>, but <span class="fixed">f x y</span>. A single higher order function can be used for a multitude of different tasks if it's general enough. Here's a little demonstration of all the different things our <span class="fixed">zipWith'</span> function can do:



As you can see, a single higher order function can be used in very versatile ways. Imperative programming usually uses stuff like for loops, while loops, setting something to a variable, checking its state, etc. to achieve some behavior and then wrap it around an interface, like a function. Functional programming uses higher order functions to abstract away common patterns, like examining two lists in pairs and doing something with those pairs or getting a set of solutions and eliminating the ones you don't need.

We'll implement another function that's already in the standard library, called <span class="fixed">flip</span>. Flip simply takes a function and returns a function that is like our original function, only the first two arguments are flipped. We can implement it like so:



Reading the type declaration, we say that it takes a function that takes an <span class="fixed">a</span> and a <span class="fixed">b</span> and returns a function that takes a <span class="fixed">b</span> and an <span class="fixed">a</span>. But because functions are curried by default, the second pair of parentheses is really unnecessary, because <span class="fixed">-&gt;</span> is right associative by default. <span class="fixed">(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</span> is the same as <span class="fixed">(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</span>, which is the same as <span class="fixed">(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span>. We wrote that <span class="fixed">g x y = f y x</span>. If that's true, then <span class="fixed">f y x = g x y</span> must also hold, right? Keeping that in mind, we can define this function in an even simpler manner.



Here, we take advantage of the fact that functions are curried. When we call <span class="fixed">f</span> without the second two parameters, it will return an <span class="fixed">f</span> that takes those two parameters but calls them flipped. Even though flipped functions are usually passed to other functions, we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were called fully applied.
