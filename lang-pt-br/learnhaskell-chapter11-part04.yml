title: A palavra chave newtype

Até agora, nós aprendemos como criar tipos de dados algébricos utilizando a palavra chave <em>data</em>. Nós aprendemos também a dar sinônimos para tipos existentes com a palavra chave <em>type</em>. Nesta seção, nós iremos dar uma olhada em como criar novos tipos a partir de tipos de dados já existentes utilizando a palavra chave <em>newtype</em> e porque nós iriamos querer fazer isso em primeiro lugar.

Na seção anterior, nós vimos que há na verdade mais formas do tipo lista ser um applicative functor. Uma delas é [code]&lt;*&gt;[/code] pegar cada função da lista a esquerda e aplicar a cada valor na lista a direita, resultando em todas as combinações possíveis ao aplicar as funções da esquerda com os valores da direita.

A segunda forma é pegar a primeira função a esquerda do [code]&lt;*&gt;[/code] e aplicar ao primeiro valor da direita, então pegar a segunda função da lista a esquerda e aplicar ao segundo valor da direita, e assim por diante. Por fim, é como se estivessemos mesclando as duas listas. Mas listas já são uma instância de [code]Applicative[/code], então como nós fazemos da lista uma instância de [code]Applicative[/code] desta segunda forma? Se você lembra, nós dissemos que o tipo [code]ZipList a[/code] foi introduzido para esse propósito, que tem um construtor, [code]ZipList[/code], que tem apenas um campo. Nós envolvemos a lista no campo. Então, [code]ZipList[/code] se torna uma instância de [code]Applicative[/code], assim quando nós queremos usar listas como aplicatives para realizar mesclagem, nós apenas envolvemos elas com o construtor [code]ZipList[/code] e então uma vez feito, recuperamos elas com [code]getZipList[/code]:

Então, o que isso tem a ver com a palavra-chave <i>newtype</i>? Bem, penso sobre como nós podemos escrever a declaração dos dados para nosso tipo [code]ZipList a[/code]. Uma forma seria fazer assim:

Um tipo que tem apenas um construtor e que o construtor tem apenas um campo que é uma lista de coisas. Nós podemos querer também usar a sintaxe do record onde nós automaticamente obtemos uma função que extrai uma lista de um [code]ZipList[/code]:

Parece bom e funciona muito bem. Nós temos duas forma de fazer um tipo existente uma instância de um tipo de classe, então nós usamos a palavra-chave <i>data</i> para envolver o tipo em outro e fazer desse uma instância desse segunda modo.

A palavra-chave <i>newtype</i> em Haskell é exatamente para estes casos quando nós queremos apenas pegar um tipo e envolver em alguma coisa para aprensentar como outro tipo. Nas bibliotecas atuais, [code]ZipList a[/code] é definido como algo assim:

Ao invés da palavra-chave <i>data</i>, a palavra-chave <i>newtype</i> é usada. Por que motivo? Bem, <i>newtype</i> é rápido. Se você usa a palavra-chave <i>data</i> para envolver um tipo, há um custo ao envolver e recuperar os dados quando seu programa está sendo executado. Mas se você usa <i>newtype</i>, Haskell sabe que você apenas está usando isso para envolver um tipo existente em um novo tipo (portanto o nome), porque você quer que internamente seja a mesma coisa mas tenha um tipo diferente. Com isso em mente, Haskell consegue eliminar o trabalho de envolver e recuperar valores uma vez que este sabe que valor é de que tipo.

Então, porque não usar <i>newtype</i> em todos os casos ao invés de <i>data</i> então? Bem, quando você cria um novo tipo a partir de um tipo existente usando a palavra-chave <i>newtype</i>, você pode ter apenas um construtor e este deve ter apenas um campo. Mas com <i>data</i>, você pode criar tipos de dados com mais de um construtor e cada construtor pode ter zero ou mais campos:

Quando usamos <i>newtype</i>, estamos restritos apenas um construtor com apenas um campo.

Nós também podemos usar a palavra-chave <i>deriving</i> com <i>newtype</i> assim como usamos com <i>data</i>. Nós podemos derivar instâncias para [code]Eq[/code], [code]Ord[/code], [code]Enum[/code], [code]Bounded[/code], [code]Show[/code] e [code]Read[/code]. Se derivarmos a instância para um tipo de classe, o tipo que estamos envolvendo tem de estar nesses tipos também. Faz sentido, porque <i>newtype</i> apenas envolve um tipo existente. Então agora, se nós fizermos o seguinte, nós podemos imprimir e comparar valores do nosso tipo:

Vamos dar uma olhada:

Nesse <i>newtype</i> em particular, o valor do construtor tem o seguinte tipo:

Este recebe um valor do tipo [code][Char][/code], como [code]"my sharona"[/code] e retorna um valor do tipo [code]CharList[/code]. A partir dos exemplos acima onde nós usamos o construtor [code]CharList[/code], nós vimos que esse é realmente um caso. Inversamente, a função [code]getCharList[/code], o qual foi gerada para nós já que usamos a sintaxe record em nosso newtype, tem este tipo:

Este recebe um valor do tipo [code]CharList[/code] e converte para um valor do tipo [code][Char][/code]. Você pode pensar nisso como envolvendo e recuperando, mas você também pode pensar nisso como uma conversão de valores de um tipo para outro.

<h3>Usando newtype para criar instâncias de um tipo de classe</h3>

Muitas vezes, nós queremos fazer dos nossos tipos instâncias de um certo tipo de classe, mas o tipo dos parâmetros não casam com o que nós queremos fazer. É fácil fazer de [code]Maybe[/code] uma instância de [code]Functor[/code], porque o tipo de classe [code]Functor[/code] é definido assim:

Então nós apenas começamos com:

E então implementamos [code]fmap[/code]. Todos os tipos de parâmetros fazem sentido aqui porque [code]Maybe[/code] toma o lugar de [code]f[/code] na definição do tipo de classe [code]Functor[/code], então se nós olharmos [code]fmap[/code] como se ele apenas funcionasse com [code]Maybe[/code], ele acaba se comportando da seguinte maneira:

Não é excelente? Agora, e se nós quisermos fazer da tupla uma instância de [code]Functor[/code], de uma forma que quando nós usarmos [code]fmap[/code] em uma tupla este é aplicado ao primeiro item da tupla? Dessa forma, fazendo [code]fmap (+3) (1,1)[/code] resultaria em [code](4,1)[/code]. Escrever uma instância para isso parece difícil. Com [code]Maybe[/code] nós apenas fazemos [code]instance Functor Maybe where[/code], porque apenas construtores de tipo que recebem exatamente um parâmetro podem se tornar uma instância de [code]Functor[/code]. Mas parece que não tem uma forma de fazer algo assim com [code](a,b)[/code], então o parâmetro do tipo [code]a[/code] acaba sendo o parâmetro que muda quando nós usamos [code]fmap[/code]. Para contornar isso, nós podemos usar <i>newtype</i> em nossa tupla de uma forma que o segundo parâmetro represente o tipo do primeiro item na tupla:

E agora, nós podemos fazer disso uma instância de [code]Functor[/code] da forma que a função é mapeada sobre o primeiro componente:

Como você pode ver, nós podemos casar padrões de tipos definidos com <i>newtype</i>. Nós casamos padrões para obter a tupla subjacente, então nós aplicamos a função [code]f[/code] ao primeiro componente da tupla e então usamos o construtor [code]Pair[/code] para converter a tuple de volta para [code]Pair b a[/code]. Se nós imaginarmos que o tipo [code]fmap[/code] poderia ser se apenas trabalhasse nos nossos novos pares, este seria:

Novamente, escrevemos [code]instance Functor (Pair c) where[/code] e assim [code]Pair c[/code] toma o lugar de [code]f[/code] na definição do tipo de classe para [code]Functor[/code]:

Então agora, se nós convertermos a tupla em [code]Pair b a[/code], nós podemos usar [code]fmap[/code] nela e a função será mapeada sobre o primeiro componente:


<h3>A avaliação sob demanda de newtype</h3>

Nós mencionamos que <i>newtype</i> geralmente é mais rápido que <i>data</i>. A única coisa que pode ser feita com <i>newtype</i> é transformar um tipo existente em um novo tipo, então internamente, Haskell pode representar os valores dos tipos definidos com <i>newtype</i> como os originais, apenas tem de manter em mente que seus tipos agora são distintos. Isso significa que <i>newtype</i> não é apenas mais rápido, este é também avaliado sob demanda. Vamos dar uma olhada no que isso significa.


Like we've said before, Haskell is lazy by default, which means that only when we try to actually print the results of our functions will any computation take place. Furthemore, only those computations that are necessary for our function to tell us the result will get carried out. The [code]undefined[/code] value in Haskell represents an erronous computation. If we try to evaluate it (that is, force Haskell to actually compute it) by printing it to the terminal, Haskell will throw a hissy fit (technically referred to as an exception):

However, if we make a list that has some [code]undefined[/code] values in it but request only the head of the list, which is not [code]undefined[/code], everything will go smoothly because Haskell doesn't really need to evaluate any other elements in a list if we only want to see what the first element is:


Now consider the following type:

It's your run-of-the-mill algebraic data type that was defined with the <i>data</i> keyword. It has one value constructor, which has one field whose type is [code]Bool[/code]. Let's make a function that pattern matches on a [code]CoolBool[/code] and returns the value [code]"hello"[/code] regardless of whether the [code]Bool[/code] inside the [code]CoolBool[/code] was [code]True[/code] or [code]False[/code]:

Instead of applying this function to a normal [code]CoolBool[/code],let's throw it a curveball and apply it to [code]undefined[/code]!

Yikes! An exception! Now why did this exception happen? Types defined with the <i>data</i> keyword can have multiple value constructors (even though [code]CoolBool[/code] only has one). So in order to see if the value given to our function conforms to the [code](CoolBool _)[/code] pattern, Haskell has to evaluate the value just enough to see which value constructor was used when we made the value. And when we try to evaluate an [code]undefined[/code] value, even a little, an exception is thrown.

Instead of using the <i>data</i> keyword for [code]CoolBool[/code],let's try using <i>newtype</i>:

We don't have to change our [code]helloMe[/code] function, because the pattern matching syntax is the same if you use <i>newtype</i> or <i>data</i> to define your type. Let's do the same thing here and apply [code]helloMe[/code] to an [code]undefined[/code] value:

It worked! Hmmm, why is that? Well, like we've said, when we use <i>newtype</i>, Haskell can internally represent the values of the new type in the same way as the original values. It doesn't have to add another box around them, it just has to be aware of the values being of different types. And because Haskell knows that types made with the <i>newtype</i> keyword can only have one constructor, it doesn't 
have to evaluate the value passed to the function to make sure that it conforms to the [code](CoolBool _)[/code] pattern because <i>newtype</i> types can only have one possible value constructor and one field!

This difference in behavior may seem trivial, but it's actually pretty important because it helps us realize that even though types defined with <i>data</i> and <i>newtype</i> behave similarly from the programmer's point of view because they both have value constructors and fields, they are actually two different mechanisms. Whereas <i>data</i> can be used to make your own types from scratch, <i>newtype</i> is for making a completely new type out of an existing type. Pattern matching on <i>newtype</i> values isn't like taking something out of a box (like it is with <i>data</i>), it's more about making a direct conversion from one type to another.

<h3>[code]type[/code] vs. [code]newtype[/code] vs. [code]data[/code]</h3>

At this point, you may be a bit confused about what exactly the difference between <i>type</i>, <i>data</i> and <i>newtype</i> is, so let's refresh our memory a bit.

The <em>type</em> keyword is for making type synonyms. What that means is that we just give another name to an already existing type so that the type is easier to refer to. Say we did the following:

All this does is to allow us to refer to the [code][Int][/code] type as [code]IntList[/code]. They can be used interchangeably. We don't get an [code]IntList[/code] value constructor or anything like that.
Because [code][Int][/code] and [code]IntList[/code] are only two ways to refer to the same type, it doesn't matter which name we use in our type annotations:

We use type synonyms when we want to make our type signatures more descriptive by giving types names that tell us something about their purpose in the context of the functions where they're being used. For instance, when we used an association list of type [code][(String,String)][/code] to represent a phone book, we gave it the type synonym of [code]PhoneBook[/code] so that the type signatures of our functions were easier to read.

The <em>newtype</em> keyword is for taking existing types and wrapping them in new types, mostly so that it's easier to make them instances of certain type classes. When we use <i>newtype</i> to wrap an existing type, the type that we get is separate from the original type. If we make the following <i>newtype</i>:

We can't use [code]++[/code] to put together a [code]CharList[/code] and a list of type [code][Char][/code]. We can't even use [code]++[/code] to put together two [code]CharList[/code]s, because [code]++[/code] works only on lists and the [code]CharList[/code] type isn't a list, even though it could be said that it contains one. We can, however, convert two [code]CharList[/code]s to lists, [code]++[/code] them and then convert that back to a [code]CharList[/code].

When we use record syntax in our <i>newtype</i> declarations, we get functions for converting between the new type and the original type: namely the value constructor of our <i>newtype</i> and the function for extracting the value in its field. The new type also isn't automatically made an instance of the type classes that the original type belongs to, so we have to derive or manually write them.

In practice, you can think of <i>newtype</i> declarations as <i>data</i> declarations that can only have one constructor and one field. If you catch yourself writing such a <i>data</i> declaration, consider using <i>newtype</i>.

The <em>data</em> keyword is for making your own data types and with them, you can go hog wild. They can have as many constructors and fields as you wish and can be used to implement any algebraic data type by yourself. Everything from lists and [code]Maybe[/code]-like types to trees.

If you just want your type signatures to look cleaner and be more descriptive, you probably want type synonyms. If you want to take an existing type and wrap it in a new type in order to make it an instance of a type class, chances are you're looking for a <i>newtype</i>. And if you want to make something completely new, odds are good that you're looking for the <i>data</i> keyword.
