chapter: Entrada e Saída

text: Nós mencionamos que Haskell é uma linguagem puramente funcional. Enquanto nas linguagens imperativas você usualmente faz as coisas passando ao computador uma série de passos para executar, em programação funcional define-se mais como as coisas são. Em Haskell, uma função não pode mudar algum estado, como mudar o conteúdo de uma variável (quando uma função muda um estado, dizemos que a função tem <i>efeitos colaterais</i>). A única coisa que uma função pode fazer em Haskell é nos devolver um resultado baseado nos parâmetros que passamos a ela. Se uma função é chamada duas vezes com os mesmos parâmetros, ela tem que devolver o mesmo resultado. Embora possa parecer um pouco limitador quando você vem de um mundo imperativo, temos visto que isso é na verdade muito legal. Em uma linguagem imperativa, você não tem garantia que uma simples função que deveria apenas moer alguns números não vai incendiar sua casa, sequestrar seu cachorro e arranhar seu carro com uma batata enquanto mói esses números. Por exemplo, quando estamos fazendo uma árvore binária de busca, nós não inserimos um elemento em uma árvore modificando alguma árvore existente. Nossa função para inserir em uma árvore binária de busca na verdade retorna uma nova árvore, porque nós não podemos modificar a original.

Embora funções que são incapazes de mudar estados sejam boas por nos ajudar a manter o foco nos nossos programas, existe um problema com elas. Se uma função não pode mudar qualquer coisa no mundo, como ela poderá nos dizer o que ela calculou? Com intúito de nos dizer o que ela calculou, ela tem que mudar o estado de um dispositivo de saída (usualmente o estado da tela), a qual então emite fótons que viajam para o nosso cérebro e mudam o estado da nossa mente.

Não se desespere, nem tudo está perdido. Verifica-se que Haskell na verdade tem um sistema bastante hábil para lidar com funções que têm efeitos colaterais que nitidamente separa a parte pura do nosso programa da parte impura, a qual faz todo o trabalho sujo de se comunicar com o teclado e com a tela. Com essas duas partes separadas, nós ainda podemos nos concentrar na parte pura do nosso programa e levar vantagem de todas as coisas que a pureza oferece, como preguiça, robustez e modularidade enquanto nos comunicamos eficientemente com o mundo externo.

title: Olá, mundo!

text: Até agora, nós sempre carregamos nossas funções no GHCI para testá-las e brincar com elas. Nós também exploramos a biblioteca padrão de funções dessa maneira. Mas agora, após oito capítulos ou mais, nós finalmente vamos escrever nosso primeiro programa Haskell <i>real</i>! E com bastante certeza, vamos usar o bom e velho artifício do [code]"olá, mundo"[/code].

<em>Ei!</em> No decorrer desse capítulo, irei assumir que você está utilizando um ambiente baseado em unix para aprender Haskell. Se você esta no Windows, eu sugiro que você faça o download do <a href="http://www.cygwin.com/">Cygwin</a>, que é um ambiente baseado em Linux para Windows, também conhecido como "exatamente o que você procura".

Então, para os iniciantes, digite o seguinte no seu editor de texto favorito:

Nós acabamos de definir um nome chamado [code]main[/code] e nele nós chamamos uma função chamada [code]putStrLn[/code] com o parâmetro [code]"hello, world"[/code]. Parece medíocre, mas não é, como nós veremos dentro de poucos momentos. Salve esse arquivo como [code]helloworld.hs[/code].

E agora, nos vamos fazer algo que nunca fizemos antes. Vamos na verdade compilar nosso programa! Estou muito animado! Abra o seu terminal e navegue até o diretório onde está o arquivo [code]helloworld.hs[/code] e faça o seguinte:

Ok! Com alguma sorte, você verá algo como isto e agora você poderá executar seu programa através do comando [code]./helloworld[/code].

E aqui vamos nós, nosso primeiro programa compilado que imprimiu alguma coisa no terminal. Que extraordinariamente chato!

Vamos examinar o que nós escrevemos. Primeiro, vamos olhar para o tipo da função [code]putStrLn[/code].

Nós podemos ler o tipo de [code]putStrLn[/code] assim: [code]putStrLn[/code] pega uma string e retorna uma <em>ação de E/S</em> que tem um resultado do tipo [code]()[/code] (i.e. uma tupla vazia, também conhecida como unidade). Uma ação de E/S é alguma coisa que, quando executada, irá realizar uma ação com um efeito colateral (que é usualmente ler do dispositivo de entrada ou imprimir algo na tela) e irá também conter algum tipo de valor de retorno dentro dela. Imprimir uma string no terminal realmente não tem nenhum tipo de valor de retorno significativo, então um valor irrelevante [code]()[/code] é usado.

A tupla vazia é um valor [code]()[/code] e também tem um tipo [code]()[/code].</div>

<p>Então, quando será executada uma ação de E/S? Bem, será onde [code]main[/code] estiver. Uma ação de E/S será executada quando nós dermos a ela um nome [code]main[/code] e então executarmos nosso programa.

Seu programa ser somente uma ação de E/S parece um tipo de limitação. Por isso nós podemos usar a sintaxe <i>do</i> para unir várias ações de E/S em uma só. Veja o seguinte exemplo:

Ah, interessante, nova sintaxe! E isso parece muito mais com um programa imperativo. Se você compilar e tentar executar, ele irá se comportar exatamente como você esperaria. Note que nós escrevemos <i>do</i> e então escrevemos uma série de passos, como faríamos em um programa imperativo. Cada um desses passos é uma ação de E/S. Colocando-as juntas com a sintaxe <i>do</i>, nós as transformamos em uma única ação de E/S. A ação que nós obtivemos tem um tipo [code]IO ()[/code], porque esse é o tipo da última ação de E/S dentro dela.

Por causa disso, [code]main[/code] sempre tem uma assinatura de tipo [code]main :: IO <i>alguma coisa</i>[/code], em que [code]<i>alguma coisa</i>[/code] é algum tipo concreto. Por convenção, nós usualmente não especificamos uma declaração de tipo para [code]main[/code].

Uma coisa interessante que nós não tínhamos visto antes é a terceira linha, que diz [code]name &lt;- getLine[/code]. Parece que uma linha é lida do dispositivo de entrada e armazenada em uma variável chamada [code]name[/code]. É realmente isso? Bem, vamos examinar o tipo de [code]getLine[/code].

Aha, ok. [code]getLine[/code] é uma ação de E/S que contém um resultado do tipo [code]String[/code]. Isso faz sentido, porque ela irá aguardar que o usuário digite algo no terminal e então que algo seja representado como uma string. Então o que acontece com [code]name &lt;- getLine[/code]? Você pode ler esse trecho de codigo assim: <em>execute a ação de E/S [code]getLine[/code] e então associe o valor do seu resultado a [code]name[/code]</em>. [code]getLine[/code] tem um tipo [code]IO String[/code], então [code]name[/code] terá um tipo [code]String[/code]. Você pode pensar em uma ação de E/S como sendo uma caixa com pequenos pés que irá sair para o mundo real e fazer algo lá (como grafitar algo em uma parede) e talvez trazer consigo alguma informação. Uma vez que ela tenha trazido as informações a você, a única maneira de abrir a caixa e obter a informação dentro dela é usando o operador [code]&lt;-[/code]. E se nós estamos tirando dados de uma ação de E/S, só podemos fazê-lo quando estamos dentro de outra ação de E/S. É dessa forma que Haskell nitidamente separa as partes pura e impura do nosso código. Desse ponto de vista [code]getLine[/code] é impura porque não há garantia de que o seu resultado será o mesmo quando executada duas vezes. Isso ocorre devido a uma espécie de <i>contaminação</i> pelo uso do construtor de tipo [code]IO[/code] e nós somente podemos retirar esses dados da ação de E/S dentro de código de E/S. Além disso, devido ao código de E/S também ser contaminado, qualquer computação que dependa de informação de E/S contaminada terá um resultado contaminado.

Dê uma olhada nesse trecho de código. Ele é válido?

Se você disse não, vá comer um biscoito. Se disse sim, beba um copo de lava derretida. Brincadeira, não beba! A razão pela qual isso não funciona é que [code]++[/code] requer que ambos os parâmetros sejam listas do mesmo tipo. O parâmetro da esquerda tem o tipo [code]String[/code] (ou [code][Char][/code] se quiser), enquanto [code]getLine[/code] tem tipo [code]IO String[/code]. Você não pode concatenar uma string e uma ação de E/S. Primeiro temos que tirar o resultado de dentro da ação de E/S para obter um valor do tipo [code]String[/code] e a única maneira de fazer isso é usar algo como [code]name &lt;- getLine[/code] dentro de alguma outra ação de E/S. Se nós queremos lidar com informação impura, temos que fazê-lo em um ambiente impuro. Então a contaminação da impureza se espalha em volta quase como a praga dos zumbis e é do nosso maior interesse manter os trechos de E/S do nosso código o menor possível.

Toda ação de E/S executada tem um resultado encapsulado dentro dela. Por isso nosso exemplo anterior poderia ter sido escrito assim:

Contudo, [code]foo[/code] teria apenas um valor [code]()[/code], então fazer isso seria um pouco questionável. Observe que nós não associamos o resultado do último [code]putStrLn[/code] a nada. Isso porque em um bloco <i>do</i>, <em>o resultado da última ação não pode ser associado a um nome</em> como o das duas primeiras foram. Veremos exatamente por que isto acontece um pouco mais tarde, quando nos aventurarmos pelo mundo dos monads. Por enquanto, você pode pensar nisso como se um bloco <i>do</i> extraisse automaticamente o resultado da última ação e o associasse ao seu próprio resultado.

Exceto pela última linha, todas as linhas em um bloco <i>do</i> que não têm seus resultados associados a nenhum nome podem ser escritas como uma associação. Então [code]putStrLn "BLAH"[/code] pode ser escrito como [code]_ &lt;- putStrLn "BLAH"[/code]. Mas isso é inútil, então nós omitimos o [code]&lt;-[/code] para ações de E/S que não contêm um resultado importante, como [code]putStrLn <i>alguma coisa</i>[/code].

Iniciantes algumas vezes pensam que escrevendo

irá ler do dispositivo de entrada e então associar o valor a [code]name[/code]. Bem, não irá, tudo que isso faz é dar à ação de E/S [code]getLine[/code] um nome diferente chamado, bem, [code]name[/code]. Lembre-se, para retirar o valor de uma ação de E/S, você tem que executá-la dentro de outra ação de E/S associando seu resultado a um nome com [code]&lt;-[/code].

Ações de E/S serão executadas somente se for dado a elas um nome [code]main[/code] ou quando elas estiverem dentro de uma ação de E/S maior que nós fizermos com um bloco <i>do</i>. Nós podemos também usar um bloco <i>do</i> para unir algumas ações de E/S e então podemos usar a ação de E/S resultante em outro bloco <i>do</i> e assim por diante. De qualquer forma, elas serão executadas somente se eventualmente cairem em [code]main[/code].

Oh, certo, existe ainda mais um caso em que ações de E/S serão executadas. Quando nós digitamos uma ação de E/S no GHCI e pressionamos enter, ela é executada.

Mesmo quando nós digitamos um número ou a invocação de uma função no GHCI e pressionamos enter, ele irá avaliar (se for necessário), invocar [code]show[/code] para o resultado da avaliação e então irá imprimir essa string no terminal usando [code]putStrLn[/code] implicitamente.

Lembra-se das associações <i>let</i>? Se não, refresque sua memória lendo <a href="syntax-in-functions#let-it-be">essa seção</a>. Elas são construções da forma [code]let <i>associações</i> in <i>expressão</i>[/code], em que [code]<i>associações</i>[/code] são nomes que serão utilizados em uma expressão e [code]<i>expressão</i>[/code] é a expressão a ser avaliada que utilizará esses nomes. Também dissemos que em list comprehensions, a parte <i>in</i> não é necessária. Bem, você pode usá-las em blocos <i>do</i> quase da mesma forma que você as usa em list comprehensions. Dê uma olhada nisso:

Veja como as ações de E/S no bloco <i>do</i> estão alinhadas? Percebe também como o <i>let</i> está alinhado com as ações de E/S e os nomes do <i>let</i> estão alinhados uns com os outros? Esta é uma boa prática, porque indentação é importante em Haskell. Agora, nós escrevemos [code]map toUpper firstName[/code], o que transforma algo como [code]"John"[/code] em uma string mais legal, como [code]"JOHN"[/code]. Nós associamos strings em maiúsculas a um nome e depois as utilizamos em outra string que imprimimos no terminal.

Você pode estar se perguntando quando usar [code]&lt;-[/code] e quando usar associações <i>let</i>? Bem, lembre-se, [code]&lt;-[/code] é usado (por enquanto) para executar ações de E/S e associar seus resultados a nomes. [code]map toUpper firstName[/code], contudo, não é uma ação de E/S. É uma expressão pura em Haskell. Então, use [code]&lt;-[/code] quando você quiser associar resultados de ações de E/S a nomes e associações <i>let</i> para associar expressões puras a nomes. Escrevendo algo como [code]let firstName = getLine[/code], só teríamos dado a ação de E/S [code]getLine[/code] um nome diferente e ainda teríamos que utilizar [code]&lt;-[/code] para executá-la.

Agora iremos fazer um programa que continuamente lê uma linha e imprime a mesma linha com as palavras invertidas. A execução do programa irá terminar quando nós digitarmos uma linha em branco. Este é o programa:

Para ter uma noção do que isso faz, você pode executá-lo antes que nós analizemos o código.

<em>Dica de profissional</em>: Para rodar um programa você pode compilá-lo e rodar o arquivo executável escrevendo [code]ghc --make helloworld[/code] e então [code]./helloworld[/code] ou você pode usar o comando [code]runhaskell[/code] dessa forma: [code]runhaskell helloworld.hs[/code] e o seu programa será executado em tempo real.

First, let's take a look at the [code]reverseWords[/code] function. It's just a normal function that takes a string like [code]"hey there man"[/code] and then calls [code]words[/code] with it to produce a list of words like [code]["hey","there","man"][/code]. Then we map [code]reverse[/code] on the list, getting [code]["yeh","ereht","nam"][/code] and then we put that back into one string by using [code]unwords[/code] and the final result is [code]"yeh ereht nam"[/code]. See how we used function composition here. Without function composition, we'd have to write something like [code]reverseWords st = unwords (map reverse (words st))[/code].

What about [code]main[/code]? First, we get a line from the terminal by performing [code]getLine[/code] call that line [code]line[/code]. And now, we have a conditional expression. Remember that in Haskell, every <i>if</i> must have a corresponding <i>else</i> because every expression has to have some sort of value. We make the <i>if</i> so that when a condition is true (in our case, the line that we entered is blank), we run perform one I/O action and when it isn't, the I/O action under the <i>else</i> is performed. That's why in an I/O <i>do</i> block, <i>if</i>s have to have a form of [code]if <i>condition</i> then <i>I/O action</i> else <i>I/O action</i>.

Let's first take a look at what happens under the <i>else</i> clause. Because, we have to have exactly one I/O action after the <i>else</i>, we use a <i>do</i> block to glue together two I/O actions into one. You could also write that part out as:

This makes it more explicit that the <i>do</i> block can be viewed as one I/O action, but it's uglier. Anyway, inside the <i>do</i> block, we call [code]reverseWords[/code] on the line that we got from [code]getLine[/code] and then print that out to the terminal. After that, we just perform [code]main[/code]. It's called recursively and that's okay, because [code]main[/code] is itself an I/O action. So in a sense, we go back to the start of the program.

Now what happens when [code]null line[/code] holds true? What's after the <i>then</i> is performed in that case. If we look up, we'll see that it says [code]then return ()[/code]. If you've done imperative languages like C, Java or Python, you're probably thinking that you know what this [code]return[/code] does and chances are you've already skipped this really long paragraph. Well, here's the thing: <em>the [code]return[/code] in Haskell is really nothing like the [code]return[/code] in most other languages!</em>. It has the same name, which confuses a lot of people, but in reality it's quite different. In imperative languages, [code]return[/code] usually ends the execution of a method or subroutine and makes it report some sort of value to whoever called it. In Haskell (in I/O actions specifically), it makes an I/O action out of a pure value. If you think about the box analogy from before, it takes a value and wraps it up in a box. The resulting I/O action doesn't actually do anything, it just has that value encapsulated as its result. So in an I/O context, [code]return "haha"[/code] will have a type of [code]IO String[/code]. What's the point of just transforming a pure value into an I/O action that doesn't do anything? Why taint our program with [code]IO[/code] more than it has to be? Well, we needed some I/O action to carry out in the case of an empty input line. That's why we just made a bogus I/O action that doesn't do anything by writing [code]return ()[/code].

Using [code]return[/code] doesn't cause the I/O <i>do</i> block to end in execution or anything like that. For instance, this program will quite happily carry out all the way to the last line:

All these [code]return[/code]s do is that they make I/O actions that don't really do anything except have an encapsulated result and that result is thrown away because it isn't bound to a name. We can use [code]return[/code] in combination with [code]&lt;-[/code] to bind stuff to names.

So you see, [code]return[/code] is sort of the opposite to [code]&lt;-[/code]. While [code]return[/code] takes a value and wraps it up in a box, [code]&lt;-[/code] takes a box (and performs it) and takes the value out of it, binding it to a name. But doing this is kind of redundant, especially since you can use <i>let</i> bindings in <i>do</i> blocks to bind to names, like so:

When dealing with I/O <i>do</i> blocks, we mostly use [code]return[/code] either because we need to create an I/O action that doesn't do anything or because we don't want the I/O action that's made up from a <i>do</i> block to have the result value of its last action, but we want it to have a different result value, so we use [code]return[/code] to make an I/O action that always has our desired result contained and we put it at the end.

A <i>do</i> block can also have just one I/O action. In that case, it's the same as just writing the I/O action. Some people would prefer writing [code]then do return ()[/code] in this case because the <i>else</i> also has a <i>do</i>.

Before we move on to files, let's take a look at some functions that are useful when dealing with I/O.

[function]putStr[/function] is much like [code]putStrLn[/code] in that it takes a string as a parameter and returns an I/O action that will print that string to the terminal, only [code]putStr[/code] doesn't jump into a new line after printing out the string while [code]putStrLn[/code] does.

Its type signature is [code]putStr :: String -&gt; IO ()[/code], so the result encapsulated within the resulting I/O action is the unit. A dud value, so it doesn't make sense to bind it.

[function]putChar[/function] takes a character and returns an I/O action that will print it out to the terminal.

[code]putStr[/code] is actually defined recursively with the help of [code]putChar[/code]. The edge condition of [code]putStr[/code] is the empty string, so if we're printing an empty string, just return an I/O action that does nothing by using [code]return ()[/code]. If it's not empty, then print the first character of the string by doing [code]putChar[/code] and then print of them using [code]putStr[/code].

See how we can use recursion in I/O, just like we can use it in pure code. Just like in pure code, we define the edge case and then think what the result actually is. It's an action that first outputs the first character and then outputs the rest of the string.

[function]print[/function] takes a value of any type that's an instance of [code]Show[/code] (meaning that we know how to represent it as a string), calls [code]show[/code] with that value to stringify it and then outputs that string to the terminal. Basically, it's just [code]putStrLn . show[/code]. It first runs [code]show[/code] on a value and then feeds that to [code]putStrLn[/code], which returns an I/O action that will print out our value.

As you can see, it's a very handy function. Remember how we talked about how I/O actions are performed only when they fall into [code]main[/code] or when we try to evaluate them in the GHCI prompt? When we type out a value (like [code]3[/code] or [code][1,2,3][/code]) and press the return key, GHCI actually uses [code]print[/code] on that value to display it on our terminal!

When we want to print out strings, we usually use [code]putStrLn[/code] because we don't want the quotes around them, but for printing out values of other types to the terminal, [code]print[/code] is used the most.

[function]getChar[/function] is an I/O action that reads a character from the input. Thus, its type signature is [code]getChar :: IO Char[/code], because the result contained within the I/O action is a [code]Char[/code]. Note that due to buffering, reading of the characters won't actually happen until the user mashes the return key.

This program looks like it should read a character and then check if it's a space. If it is, halt execution and if it isn't, print it to the terminal and then do the same thing all over again. Well, it kind of does, only not in the way you might expect. Check this out:

The second line is the input. We input [code]hello sir[/code] and then press return. Due to buffering, the execution of the program will begin only when after we've hit return and not after every inputted character. But once we press return, it acts on what we've been putting in so far. Try playing with this program to get a feel for it!

The [function]when[/function] function is found in [code]Control.Monad[/code] (so to get access to it, do [code]import Control.Monad[/code]. It's interesting because in a <i>do</i> block it looks like a control flow statement, but it's actually a normal function. It takes a boolean value and an I/O action if that boolean value is [code]True[/code], it returns the same I/O action that we supplied to it. However, if it's [code]False[/code], it returns the [code]return ()[/code], action, so an I/O action that doesn't do anything. Here's how we could rewrite the previous piece of code with which we demonstrated [code]getChar[/code] by using [code]when[/code]:

So as you can see, it's useful for encapsulating the [code]if <i>something</i> then do <i>some I/O action</i> else return ()[/code] pattern.

[function]sequence[/function] takes a list of I/O actions and returns an I/O actions that will perform those actions one after the other. The result contained in that I/O action will be a list of the results of all the I/O actions that were performed. Its type signature is [code]sequence :: [IO a] -&gt; IO [a][/code]. Doing this:

Is exactly the same as doing this:.

So [code]sequence [getLine, getLine, getLine][/code] makes an I/O action that will perform [code]getLine[/code] three times. If we bind that action to a name, the result is a list of all the results, so in our case, a list of three things that the user entered at the prompt.

A common pattern with [code]sequence[/code] is when we map functions like [code]print[/code] or [code]putStrLn[/code] over lists. Doing [code]map print [1,2,3,4][/code] won't create an I/O action. It will create a list of I/O actions, because that's like writing [code][print 1, print 2, print 3, print 4][/code]. If we want to transform that list of I/O actions into an I/O action, we have to sequence it.

What's with the [code][(),(),(),(),()][/code] at the end? Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is [code]()[/code], in which case it's not printed out. That's why evaluating [code]putStrLn "hehe"[/code] in GHCI just prints out [code]hehe[/code] (because the contained result in [code]putStrLn "hehe"[/code] is [code]()[/code]). But when we do [code]getLine[/code] in GHCI, the result of that I/O action is printed out, because [code]getLine[/code] has a type of [code]IO String[/code].

Because the mapping a function that returns an I/O action over a list and then sequencing it so common, the utility functions [function]mapM[/function] and [function]mapM_[/function] were introduced. [code]mapM[/code] takes a function and a list, maps the function over the list and then sequences it. [code]mapM_[/code] does the same, only it throws away the result later. We usually use [code]mapM_[/code] when we don't care what result our sequenced I/O actions have.

[function]forever[/function] takes an I/O action and returns an I/O action that just repeats the I/O action it got forever. It's located in [code]Control.Monad[/code]. This little program will indefinitely ask the user for some input and spit it back to him, CAPSLOCKED:

[function]forM[/function] (located in [code]Control.Monad[/code]) is like [code]mapM[/code], only that it has its parameters switched around. The first parameter is the list and the second one is the function to map over that list, which is then sequenced. Why is that useful? Well, with some creative use of lambdas and <i>do</i> notation, we can do stuff like this:

The [code](\a -&gt; do ... )[/code] is a function that takes a number and returns an I/O action. We have to sorround it with parentheses, otherwise the lambda thinks the last two I/O actions belong to it. See that we do [code]return color[/code] in the inside <i>do</i> block. We do that so that the I/O action which the <i>do</i> block defines has the result of our color contained within it. We actually didn't have to do that, because [code]getLine[/code] already has that contained within it. Doing [code]color &lt;- getLine[/code] and then [code]return color[/code] is just unpacking the result from [code]getLine[/code] and then repackaging it again, so it's the same as just doing [code]getLine[/code]. The [code]forM[/code] (called with its two parameters) produces an I/O action, whose result we bind to [code]colors[/code]. [code]colors[/code] is just a normal list that holds strings. At the end, we print out all those colors by doing [code]mapM putStrLn colors[/code].

You can think of [code]forM[/code] as meaning: make an I/O action for every element in this list. What each I/O action will do can depend on the element that was used to make the action. Finally, perform those actions and bind their results to something. We don't have to bind it, we can also just throw it away.

We could have actually done that without [code]forM[/code], only with [code]forM[/code] it's more readable. Normally we write [code]forM[/code] when we want to map and sequence some actions that we define there on the spot using <i>do</i> notation. In the same vein, we could have replaced the last line with [code]forM colors putStrLn[/code].

In this section, we learned the basics of input and output. We also found out what I/O actions are, how they enable us to do input and output and when they are actually performed. To reiterate, I/O actions are values much like any other value in Haskell. We can pass them as parameters to functions and functions can return I/O actions as results. What's special about them is that if they fall into the [code]main[/code] function (or are the result in a GHCI line), they are performed. And that's when they get to write stuff on your screen or play Yakety Sax through your speakers. Each I/O action can also encapsulate a result with which it tells you what it got from the real world.

Don't think of a function like [code]putStrLn[/code] as a function that takes a string and prints it to the screen. Think of it as a function that takes a string and returns an I/O action. That I/O action will, when performed, print beautiful poetry to your terminal.