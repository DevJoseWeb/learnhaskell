title:Então, o que é Haskell?
text: Haskell é uma linguagem de programação puramente funcional.
Em linguagens de programação imperativas você pensa nas coisas seguindo uma sequência computacional de tarefas sendo executadas. Embora durante a execução elas possam mudar de estado. Por exemplo, você define uma variável como 5 e então faz alguma coisa e em seguida a define como sendo alguma outra coisa qualquer. Você possui o controle do fluxo da estrutura podendo fazer uma determinada ação diversas vezes. Na programação puramente funcional você não diz para o computador o que fazer, porém você diz muitas vezes em qual coisa esta. O fatorial de um número é o produto de todos os números sobre 1 deste número, a soma de uma lista de números é o primeiro número mais a soma de todos os outros números e assim por diante. Você expressa isto na forma de funções. Você também não pode definir uma variável como sendo alguma coisa e em seguida defini-lá como sendo alguma outra coisa mais tarde. Se você dizer a ela que é 5, você não poderá dizer que é outra coisa mais tarde porque você já disse que era 5.  O que você é, algum tipo de mentiroso? Então, em linguagens puramente funcionais, uma função não tem efeitos colaterais. A única coisa que podemos fazer com uma função é calcular algo e devolvê-lo como um resultado. Inicialmente, eu vi isto como uma limitação porém isto realmente tem algumas consequências interessantes: se a função é chamada duas vezes com os mesmos parâmetros, isto garantirá o retorno de um mesmo resultado. Isto se chama transparência referencial e não só permite que o compilador raciocine sobre o comportamento do programa, como também permite que você deduza fácilmente (e até mesmo prove) que uma função está correta e, em seguida, construa funções mais complexas juntando diversas funções simples por colagem.


Haskell é preguiçoso. Isso significa que, salvo caso seja especificamente dito de outro modo, Haskell não irá executar funções e calcular as coisas antes que ele seja realmente obrigado a lhe mostrar um resultado. Isto vai bem de encontro com a transparência referencial que lhe permite pensar em programas como uma série de transformações nos dados. Isto também permite arrefecer coisas tais como estruturas de dados infinitas. Digamos que você tem uma lista de números imutáveis [code] xs = [1,2,3,4,5,6,7,8] [/ code] e uma função [code] doubleMe [/ code] que multiplica cada elemento por 2 e em seguida retorna uma nova lista. Caso quiséssemos multiplicar nossa lista por 8 em uma linguagem imperativa fazendo [code] doubleMe (doubleMe (doubleMe (xs )))[/ code], ele provavelmente iria passar uma vez pela lista, fazer uma cópia e retornar isto. Em seguida, ele iria passar por mais duas vezes na lista e retornar o resultado. Em uma linguagem preguiçosa, chamando [code] doubleMe [/ code] numa lista sem forçar para que seja mostrado algum resultado assim que acabar, ela irá lhe dizer "Sim sim, irei fazer isso mais tarde!". Mas uma vez que você queira ver o resultado, o primeiro [code] doubleMe [/ code] dirá para o segundo que quer o resultado do 1, agora! O segundo 1 irá dizer para o terceiro 1 e o terceiro 1 relutantemente irá retornar o 1 duplicado, que é um 2. O segundo 1 recebido irá retornar um 4 para o primeiro. O primeiro 1 olhará aquilo e dirá para você que o primeiro elemento é 8. Por isso, ele só passa uma vez pela lista e só quando você realmente precisa dela. Dessa maneira, quando você quiser alguma coisa a partir de uma linguagem preguiçosa você pode ter apenas alguns dados iniciais e eficientemente transforma-los e melhora-los para que eles se assemelhem com aquilo que você quer no final.

Haskell é estaticamente tipada. Quando você compilar seu programa, o compilador saberá quais partes do código é um número, o que é uma string e assim por diante. Isso significa que uma série de possíveis erros poderão ser capturados em  tempo de compilação. Se você tentar adicionar um número a uma string, o compilador irá se queixar de você. Haskell usa um bom sistema de tipos que tem tipo de inferência. Isso significa que você não precisa explicitamente identificar cada pedaço de código com um tipo porque o sistema de tipos inteligente descobrirá muito sobre ele. Se você disser [code] a = 5 + 4 [/ code], você não precisará dizer para o Haskell que [código] a [/ code] é um número, ele irá descobrir isso por si só. Tipo de inferência também permite que o seu código seja mais geral. Se você fizer uma função com dois parâmetros e adiciona-los juntos e você não declarar explicitamente o seu tipo, a função irá trabalhar com qualquer um dos dois parâmetros que seja um número.

Haskell é <em> elegante e conciso </ em>. Isto porque ele utiliza uma série de conceitos de alto nível, programas Haskell são normalmente mais curtos do que os seus equivalentes imperativos. E programas mais curtos são mais fáceis de se manter e têm menos bugs.

Haskell foi feito por alguns caras realmente inteligentes (com doutorado). O trabalho sobre Haskell começou em 1987 quando uma comissão de pesquisadores se reuniu para conceberem o designer de uma linguagem "chuta-bundas". Em 2003 o relatório sobre Haskell foi publicado, com uma versão estável definida no idioma.
