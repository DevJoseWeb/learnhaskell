title:Então, o que é Haskell?
text: Haskell é uma linguagem de programação puramente funcional.
Em linguagens de programação imperativas você pensa nas coisas seguindo uma sequência computacional de tarefas sendo executadas. Embora durante a execução elas possam mudar de estado. Por exemplo, você define uma variável como 5 e então faz alguma coisa e em seguida a define como sendo alguma outra coisa qualquer. Você possui o controle do fluxo da estrutura podendo fazer uma determinada ação diversas vezes. Na programação puramente funcional você não diz para o computador o que fazer, porém você diz muitas vezes em qual coisa esta. O fatorial de um número é o produto de todos os números sobre 1 deste número, a soma de uma lista de números é o primeiro número mais a soma de todos os outros números e assim por diante. Você expressa isto na forma de funções. Você também não pode definir uma variável como sendo alguma coisa e em seguida defini-lá como sendo alguma outra coisa mais tarde. Se você dizer a ela que é 5, você não poderá dizer que é outra coisa mais tarde porque você já disse que era 5.  O que você é, algum tipo de mentiroso? Então, em linguagens puramente funcionais, uma função não tem efeitos colaterais. A única coisa que podemos fazer com uma função é calcular algo e devolvê-lo como um resultado. Inicialmente, eu vi isto como uma limitação porém isto realmente tem algumas consequências interessantes: se a função é chamada duas vezes com os mesmos parâmetros, isto garantirá o retorno de um mesmo resultado. Isto se chama transparência referencial e não só permite que o compilador raciocine sobre o comportamento do programa, como também permite que você deduza fácilmente (e até mesmo prove) que uma função está correta e, em seguida, construa funções mais complexas juntando diversas funções simples por colagem.


Haskell is lazy. That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result. That goes well with referential transparency and it allows you to think of programs as a series of transformations on data. It also allows cool things such as infinite data structures. Say you have an immutable list of numbers [code]xs = [1,2,3,4,5,6,7,8][/code] and a function [code]doubleMe[/code] which multiplies every element by 2 and then returns a new list. If we wanted to multiply our list by 8 in an imperative language and did [code]doubleMe(doubleMe(doubleMe(xs)))[/code], it would probably pass through the list once and make a copy and then return it. Then it would pass through the list another two times and return the result. In a lazy language, calling [code]doubleMe[/code] on a list without forcing it to show you the result ends up in the program sort of telling you "Yeah yeah, I'll do it later!". But once you want to see the result, the first [code]doubleMe[/code] tells the second one it wants the result, now! The second one say that to the third one and the third one reluctantly gives back a doubled 1, which is a 2. The second one receives that and gives back 4 to the first one. The first one sees that and tells you the first element is 8. So it only does one pass through the list and only when you really need it. That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.

Haskell is statically typed. When you compile your program, the compiler knows which piece of code is a number, which is a string and so on. That means that a lot of possible errors are caught at compile time. If you try to add together a number and a string, the compiler will whine at you. Haskell uses a very good type system that has type inference. That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it. If you say [code]a = 5 + 4[/code], you don't have to tell Haskell that [code]a[/code] is a number, it can figure that out by itself. Type inference also allows your code to be more general. If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.

Haskell is <em>elegant and concise</em>. Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs.

Haskell was made by some really smart guys (with PhDs). Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language. In 2003 the Haskell Report was published, which defines a stable version of the language.

