chapter:Introdução

title:Sobre este tutorial

text: Bem-vindo ao Aprender Haskell será um grande bem para você! 
Se você já esta lendo isto, existem chances de você quer aprender Haskell. Muito Bem, você já esta no lugar certo, mas antes vamos conversar um pouco sobre este tutorial.

Eu decidi escreve-lo porque eu estava querendo solidificar meus conhecimentos em Haskell e porque pensei que poderia ajudar as pessoas novas em Haskell a aprende-lo sob a minha perspectiva. Este é só mais um tutorial sobre Haskell flutuando pela internet. Quando eu comecei em Haskell, e não aprendi a partir de apenas um recurso. O meu caminho para o aprendizado passou pela leitura de diversos e diferentes tutoriais e artigos porque cada um explicava algo seguindo por um caminho diferente do outro. Ao passar por diferentes recursos, eu consegui juntar as peças e tudo acabou caindo no mesmo lugar. Portanto, este é apenas mais um recurso adicional a se utilizar para aprender Haskell para que você tenha uma maior chance de encontrar um que você realmente goste. 

This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python &hellip;) but haven't programmed in a functional language before (Haskell, ML, OCaml &hellip;). Although I bet that even if you don't have any significant programming experience, a smart chap like you will be able to follow along and learn Haskell.

The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies.

I failed to learn Haskell approximately 2 times before finally grasping it because it all just seemed too weird to me and I didn't get it. But then once it just "clicked" and after getting over that initial hurdle, it was pretty much smooth sailing. I guess what I'm trying to say is: Haskell is great and if you're interested in programming you should really learn it even if it seems weird at first. Learning Haskell is much like learning to program for the first time &mdash; it's fun! It forces you to think differently, which brings us to the next section &hellip;


title:So what's Haskell?
text: Haskell is a purely functional programming language.
In imperative languages you get things done by giving the computer a sequence of tasks and then it executes them. While executing them, it can change state. For instance, you set variable a to 5 and then do some stuff and then set it to something else. You have control flow structures for doing some action several times. In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff is. The factorial of a number is the product of all the numbers from 1 to that number, the sum of a list of numbers is the first number plus the sum of all the other numbers, and so on. You express that in the form of functions. You also can't set a variable to something and then set it to something else later. If you say that a is 5, you can't say it's something else later because you just said it was 5. What are you, some kind of liar? So in purely functional languages, a function has no side-effects. The only thing a function can do is calculate something and return it as a result. At first, this seems kind of limiting but it actually has some very nice consequences: if a function is called twice with the same parameters, it's guaranteed to return the same result. That's called referential transparency and not only does it allow the compiler to reason about the program's behavior, but it also allows you to easily deduce (and even prove) that a function is correct and then build more complex functions by gluing simple functions together.

Haskell is lazy. That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result. That goes well with referential transparency and it allows you to think of programs as a series of transformations on data. It also allows cool things such as infinite data structures. Say you have an immutable list of numbers [code]xs = [1,2,3,4,5,6,7,8][/code] and a function [code]doubleMe[/code] which multiplies every element by 2 and then returns a new list. If we wanted to multiply our list by 8 in an imperative language and did [code]doubleMe(doubleMe(doubleMe(xs)))[/code], it would probably pass through the list once and make a copy and then return it. Then it would pass through the list another two times and return the result. In a lazy language, calling [code]doubleMe[/code] on a list without forcing it to show you the result ends up in the program sort of telling you "Yeah yeah, I'll do it later!". But once you want to see the result, the first [code]doubleMe[/code] tells the second one it wants the result, now! The second one say that to the third one and the third one reluctantly gives back a doubled 1, which is a 2. The second one receives that and gives back 4 to the first one. The first one sees that and tells you the first element is 8. So it only does one pass through the list and only when you really need it. That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.

Haskell is statically typed. When you compile your program, the compiler knows which piece of code is a number, which is a string and so on. That means that a lot of possible errors are caught at compile time. If you try to add together a number and a string, the compiler will whine at you. Haskell uses a very good type system that has type inference. That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it. If you say [code]a = 5 + 4[/code], you don't have to tell Haskell that [code]a[/code] is a number, it can figure that out by itself. Type inference also allows your code to be more general. If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.

Haskell is <em>elegant and concise</em>. Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs.

    Haskell was made by some really smart guys (with PhDs). Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language. In 2003 the Haskell Report was published, which defines a stable version of the language.


title:What you need to dive in
text: A text editor and a Haskell compiler. You probably already have your favorite text editor installed so we won't waste time on that. The two main Haskell compilers as of right now are GHC (Glasgow Haskell Compiler) and Hugs. For the purposes of this tutorial we'll be using GHC. I won't cover much installation details. On Windows it's just a matter of downloading the installer and clicking "Next" a couple of times and then rebooting your computer. On Debian based Linux distributions you can just do [code]apt-get install ghc6 libghc6-mtl-dev[/code] and you're laughing. I don't have a Mac but I've heard that if you have MacPorts, you can get GHC by doing [code]sudo port install ghc[/code]. Also, I think you can do Haskell development with that wacky mouse with one button, although I'm not sure.

GHC can take a Haskell script (they usually have a .hs extension) and compile it but it also has an interactive mode which allows you to interactively interact with scripts. Interactively. You can call functions from scripts that you load and the results are displayed immediately. For learning it's a lot easier and faster than compiling every time you make a change and then running the program from the prompt. The interactive mode is invoked by typing in <span class="fixed">ghci</span> at your prompt. If you have defined some functions in a file called, say, [code]myfunctions.hs[/code], you load up those functions by typing in [code]:l myfunctions[/code] and then you can play with them, provided [code]myfunctions.hs[/code] is in the same folder from which [code]ghci[/code] was invoked. If you change the .hs script, just run [code]:l myfunctions[/code] again or do [code]:r[/code], which is equivalent because it reloads the current script. The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on. This is also what we'll be doing here.

