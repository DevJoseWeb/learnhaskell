chapter: Recursão

title: Olá recursão!

text: We mention recursion briefly in the previous chapter. In this chapter, we'll take a closer look at recursion, why it's important to Haskell and how we can work out very concise and elegant solutions to problems by thinking recursively.

If you still don't know what recursion is, read this sentence. Haha! Just kidding! Recursion is actually a way of defining functions in which the function is applied inside its own definition. Definitions in mathematics are often given recursively. For instance, the fibonacci sequence is defined recursively. First, we define the first two fibonacci numbers non-recursively. We say that <i>F(0) = 0</i> and <i>F(1) = 1</i>, meaning that the 0th and 1st fibonacci numbers are 0 and 1, respectively. Then we say that for any other natural number, that fibonacci number is the sum of the previous two fibonacci numbers. So <i>F(n) = F(n-1) + F(n-2)</i>. That way, <i>F(3)</i> is <i>F(2) + F(1)</i>, which is <i>(F(1) + F(0)) + F(1)</i>. Because we've now come down to only non-recursively defined fibonacci numbers, we can safely say that <i>F(3)</i> is 2. Having an element or two in a recursion definition defined non-recursively (like <i>F(0)</i> and <i>F(1)</i> here) is also called the <em>edge condition</em> and is important if you want your recursive function to terminate. If we hadn't defined <i>F(0)</i> and <i>F(1)</i> non recursively, you'd never get a solution any number because you'd reach 0 and then you'd go into negative numbers. All of a sudden, you'd be saying that <i>F(-2000)</i> is <i>F(-2001) + F(-2002)</i> and there still wouldn't be an end in sight!

Recursion is important to Haskell because unlike imperative languages, you do computations in Haskell by declaring what something <i>is</i> instead of declaring <i>how</i> you get it. That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is.
