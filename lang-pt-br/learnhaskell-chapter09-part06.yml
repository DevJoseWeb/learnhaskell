title: Exceções

text: Todas linguagens tem procedures, funções e pedaços de código que em algum momento falham.
Essas coisas acontecem na vida. Para diferentes linguagens existem diferentes maneiras de lidar
com essas falhas. Em C, normalmente retornamos algum valor anormal (como [code]-1[/code] ou um ponteiro nulo)
para indicar que aquilo que a função esta retornando não deve ser tratado como um valor normal.
Java e C#, por outro lado, preferem usar exceções para lidar com falhas. Quando uma exceção é levantada,
o fluxo de controle pula para algum código que definimos para fazer alguma tratamento e talvez 
levantar novamente alguma exceção que nos levará para algum outro código que irá lidar com o erro e 
tomar conta dele. 

Haskell tem um belo sistema de tipos. Tipos de dados algébrico que permitem usarmos tipos como 
[code]Maybe[/code] e [code]Either[/code] em valores que esses tipos vão representar e que podem
ter ou não algum valor. Em C, ao retornar, digamos, [code]-1[/code] para uma falha é uma convenção
amplamente aceita. Mas ele tem significado apenas para humanos. Se não tomarmos cuidado, podemos 
cair no erro de tratar esses valores anormais como algo normal e causar um caos completo no nosso código.
O sistema de tipos em Haskell nos da algo muito mais seguro nesse aspecto. A função 
[code]a -&gt; Maybe b[/code] claramente indica que isso pode produzir um [code]b[/code] envolto por 
um [code]Just[/code] ou pode nos retornar [code]Nothing[/code]. O tipo é diferente de simplesmente 
[code]a -&gt; b[/code] e se tentarmos usar alternadamente essas duas funções, o compilador irá
reclamar para nós.

Apesar de ter tipos expressivos que suportam computações falhas, Haskell ainda tem suporte
para exceções, porque elas fazem muito mais sentido no contexto de I/O. Um bando de coisas
podem dar errado quando lidamos com o mundo externo porque ele simplesmente não é confiável. 
Por exemplo, quando abrimos um arquivo, um monte de coisas podem dar errado. O arquivo pode estar
bloqueado, ele pode não estar mais lá ou o HD ou alguma outra pode não estar mais disponível. 
Então é interessante ser capaz de pular para uma parte em no nosso código que irá lidar com o erro 
quando ele aparecer.

Beleza, então código I/O (ou código impuro) pode lançar exceções. Isso faz todo sentido. Mas e código puro?
Também pode lançar exceções. Pense sobre as funções [code]div[/code] e [code]head[/code]. 
Elas tem tipos de [code](Integral a) =&gt; a -&gt; a -&gt; a[/code] e [code][a] -&gt; a[/code], 
respectivamente. Sem [code]Maybe[/code] ou [code]Either[/code] no tipo retornado e assim mesmo
ambas podem falhar! [code]div[/code] explode na nossa cara se tentarmos dividir por zero e [code]head[/code]
tem chiliques se dermos uma lista vazia pra ele.

Código puro pode levantar exceções, mas elas apenas podem ser capturas no nível de I/O do nosso código
(quando estamos dentro do bloco <i>do</i> que esta dentro de [code]main[/code]). Isso porque você
não sabe quando (ou se) alguma coisa será avaliada em seu código puro, devido a avaliação preguiçosa e
por não termos uma ordem bem definida de execução, enquanto que códigos I/O tem.

Anteriormente, falamos sobre como devemos gastar o mínimo de tempo possível no parte de I/O do 
nosso programa. A lógica do nosso programa deve residir principalmente dentro das nossas funções puras,
porque seus resultados dependem apenas dos parâmetros com que as funções são chamadas.
Ao lidar com funções puras, você só tem que pensar sobre o que a função retorna, porque ela não
pode fazer nada além disso. Isso torna sua vida muito mais fácil. Apesar de ser necessário ter alguma 
lógica em I/O (como a abertura de arquivos e semelhantes), de preferência elas devem ter apenas
o minimamente possível. Funções puras são preguiçosas por padrão, o que significa que nós não sabemos quando 
ela será avaliada e isso realmente não importa. No entanto, uma vez que as funções puras começarem a 
jogar exceções, será importante quando elas serão avaliadas. É por isso que só podemos pegar exceções 
lançadas a partir de funções puras na parte I/O do nosso código. E isso é bem ruim, porque queremos 
manter a parte de I/O o mais enxuto possível. No entanto, se não pega-las na parte I/O do nosso código, 
nosso programa irá quebrar. A solução? Não misture exceções e código puro. Tire vantagem de poderoso 
sistema tipo de Haskell e use tipos como [code]Either[/code] e [code]Maybe[/code] para representar os 
resultados que podem falhar.

Esse é o porque que vamos apenas dar uma olhada em como usar exceções I/O por enquanto. Exceções I/O
são exceções que são causadas quando alguma coisa da errado enquanto estamos nos comunicando 
com o mundo externo em uma ação I/O que faça parte de [code]main[/code]. Por exemplo, 
se tentarmos abrir um arquivo e ele foi deletado ou coisa assim. Dê uma olhada nesse programa que 
abre um arquivo cujo nome é dado através da linha de comando do terminal e nos diz quantas linhas
o arquivo tem.

Um programa super simples. Nós processamos a ação I/O [code]getArgs[/code] e atribuimos a primeira
string da lista que é dada por [code]fileName[/code]. Então damos ao conteúdo do arquivo o nome
de [code]contents[/code]. Finalmente, aplicamos [code]lines[/code] nesse conteúdo para obter uma lista
de linhas para então saber o tamanho dessa lista e devolver isso para [code]show[/code] que terá uma
string representando esse número. Ela funciona conforme o esperado, mas e se acontecer dela receber
o nome de um arquivo que não existe?

Aha, recebemos um erro do GHC, nos dizendo que o arquivo não existe. Nosso programa quebrou. 
E se quisermos imprimir uma bela mensagem informando que o arquivo não existe? Um jeitão de fazer
isso é verificando se o arquivo existe antes de tentar abrir ele usando a função [function]doesFileExist[/code]
do módulo [code]System.Directory[/code].

Fizemos [code]fileExists &lt;- doesFileExist fileName[/code] porque [code]doesFileExist[/code] 
tem o tipo de [code]doesFileExist :: FilePath -&gt; IO Bool[/code], que significa que ele irá retornar 
uma ação I/O que tem o seu resultado representado por um valor boleano que irá nos dizer se o arquivo 
existe. Não podemos simplesmente usar [code]doesFileExist[/code] em um <i>if</i> diretamente.

Outra solução aqui pode ser o uso de exceções. Elas são perfeitamente aceitáveis dentro desse contexto.
Um arquivo não existir é uma exceção a nível de I/O, e pegar isso em I/O é tranquilo e belezinha.

Para lidar com isso usando exceções, podemos tirar vantagem da função [function]catch[/code] de 
[code]System.IO.Error[/code]. O tipo dela é [code]catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a[/code].
Ela recebe dois parâmetros. O primeiro é uma ação I/O. Que pode ser por exemplo uma ação I/O que 
tenta abrir um arquivo. O segundo é um pseudo handler. Se a primeira ação I/O fornecida para o [code]catch[/code]
lançar uma exceção I/O, essa exceção será passada para o handler, que vai decidir o que fazer.
Então o resultado final é uma ação I/O que irá agir de acordo com o primeiro parametro ou que irá fazer 
o que o handler quiser caso a primeira ação I/O levantar uma exceção.

Se você já é familiarizado com os blocos <i>try-catch</i> de linguagens como Java ou Python, então a 
função [code]catch[/code] é semelhante a eles. O primeiro parâmetro é aquela coisa que vamos tentar,
o tipo de coisa que é feito em blocos <i>try</i> de linguagens imperativas. O segundo parâmetro é 
o handler que cuida da exceção, assim como a maioria dos blocos <i>catch</i> que pegam a exceção
que você quer dar uma examinada pra ver o que aconteceu. O handler é envocado se uma exceção é levantada. 

O handler pega um valor do tipo [code]IOError[/code], que é um valor que significa que uma exceção I/O
aconteceu. Isso também carrega infomação em relação ao tipo de exceção que foi levantada.
Como esse tipo é implementado depende da implementação da própria linguagem, que significa que não
podemos inspecionar valores do tipo [code]IOError[/code] por pattern matching, assim 
como não podemos usar pattern match em valores do tipo [code]IO <i>qualquer-coisa</i>[/code].
Podemos usar vários predicados úteis para encontrar coisas sobre valores do tipo [code]IOError[/code] 
que é o que já iremos aprender dentro de alguns segundos.

Vamos colocar então o nosso novo amiguinho [code]catch[/code] pra funcionar!

Primeiramente, notamos que se colocarmos aqueles <i>backticks</i> (pequeno caracter: `) ao redor nós 
podemos usa-lá como uma função infixa, porque ela recebe dois parâmetros. Usando como uma função
infixa ela fica mais legível. Então [code]toTry `catch` handler[/code] é o mesmo que 
[code]catch toTry handler[/code], que encaixa bem com o seu tipo. [code]toTry[/code] é a ação I/O
que nós tentamos executar e [code]handler[/code] é a função que recebe um [code]IOError[/code] e 
retorna uma ação para ser executada no caso de exceção.

Vamos colocar isso pra rodar:

In the handler, we didn't check to see what kind of [code]IOError[/code] we got. 
We just say [code]"Whoops, had some trouble!"[/code] for any kind of error. 
Just catching all types of exceptions in one handler is bad practice in Haskell just like it is 
in most other languages. What if some other exception happens that we don't want to catch, 
like us interrupting the program or something? That's why we're going to do the same thing 
that's usually done in other languages as well: we'll check to see what kind of exception we got. 
If it's the kind of exception we're waiting to catch, we do our stuff. 
If it's not, we throw that exception back into the wild. Let's modify our program to catch only 
the exceptions caused by a file not existing.


Everything stays the same except the handler, which we modified to only catch a certain group 
of I/O exceptions. Here we used two new functions from [code]System.IO.Error[/code] — 
[function]isDoesNotExistError[/code] and [function]ioError[/code]. [code]isDoesNotExistError[/code] 
is a predicate over [code]IOError[/code]s, which means that it's a function that takes an 
[code]IOError[/code] and returns a [code]True[/code] or [code]False[/code], meaning it has a 
type of [code]isDoesNotExistError :: IOError -&gt; Bool[/code]. We use it on the exception that 
gets passed to our handler to see if it's an error caused by a file not existing. 
We use <a href="syntax-in-functions#guards-guards">guard</a> syntax here, but we could have also 
used an <i>if else</i>. If it's not caused by a file not existing, we re-throw the exception 
that was passed by the handler with the [code]ioError[/code] function. It has a type of 
[code]ioError :: IOException -&gt; IO a[/code], so it takes an [code]IOError[/code] and produces an 
I/O action that will throw it. The I/O action has a type of [code]IO a[/code], because it never 
actually yields a result, so it can act as [code]IO <i>anything</i>[/code].


So the exception thrown in the [code]toTry[/code] I/O action that we glued together with a 
<i>do</i> block isn't caused by a file existing, [code]toTry `catch` handler[/code] will 
catch that and then re-throw it. Pretty cool, huh?

There are several predicates that act on [code]IOError[/code] and if a guard doesn't evaluate to 
[code]True[/code], evaluation falls through to the next guard. The predicates that act on 
[code]IOError[/code] are:


Most of these are pretty self-explanatory. [code]isUserError[/code] evaluates to 
[code]True[/code] when we use the function [function]userError[/code] to make the exception, 
which is used for making exceptions from our code and equipping them with a string. For instance, 
you can do [code]ioError $ userError "remote computer unplugged!"[/code], although It's prefered 
you use types like [code]Either[/code] and [code]Maybe[/code] to express possible failure instead 
of throwing exceptions yourself with [code]userError[/code].

So you could have a handler that looks something like this:


Where [code]notifyCops[/code] and [code]freeSomeSpace[/code] are some I/O actions that you define. 
Be sure to re-throw exceptions if they don't match any of your criteria, otherwise you're causing 
your program to fail silently in some cases where it shouldn't.

[code]System.IO.Error[/code] also exports functions that enable us to ask our exceptions for some 
attributes, like what the handle of the file that caused the error is, or what the filename is. 
These start with [code]ioe[/code] and you can see a 
<a href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">full list of them</a> 
in the documentation. Say we want to print the filename that caused our error. We can't print the 
[code]fileName[/code] that we got from [code]getArgs[/code], because only the [code]IOError[/code] 
is passed to the handler and the handler doesn't know about anything else. 
A function depends only on the parameters it was called with. That's why we can use the 
[function]ioeGetFileName[/code] function, which has a type of 
[code]ioeGetFileName :: IOError -&gt; Maybe FilePath[/code]. It takes an [code]IOError[/code] 
as a parameter and maybe returns a [code]FilePath[/code] (which is just a type synonym for 
	[code]String[/code], remember, so it's kind of the same thing). Basically, what it does is it 
extracts the file path from the [code]IOError[/code], if it can. Let's modify our program to 
print out the file path that's responsible for the exception occurring.


In the guard where [code]isDoesNotExistError[/code] is [code]True[/code], we used a <i>case</i> 
expression to call [code]ioeGetFileName[/code] with [code]e[/code] and then pattern match against 
the [code]Maybe[/code] value that it returned. Using <i>case</i> expressions is commonly used when 
you want to pattern match against something without bringing in a new function.


You don't have to use one handler to [code]catch[/code] exceptions in your whole I/O part. 
You can just cover certain parts of your I/O code with [code]catch[/code] or you can cover several 
of them with [code]catch[/code] and use different handlers for them, like so:


Here, [code]toTry[/code] uses [code]handler1[/code] as the handler and [code]thenTryThis[/code] 
uses [code]handler2[/code]. [code]launchRockets[/code] isn't a parameter to [code]catch[/code], 
so whichever exceptions it might throw will likely crash our program, unless [code]launchRockets[/code] 
uses [code]catch[/code] internally to handle its own exceptions. Of course [code]toTry[/code], 
[code]thenTryThis[/code] and [code]launchRockets[/code] are I/O actions that have been glued 
together using <i>do</i> syntax and hypothetically defined somewhere else. This is kind of similar 
to <i>try-catch</i> blocks of other languages, where you can surround your whole program in a single 
<i>try-catch</i> or you can use a more fine-grained approach and use different ones in different parts 
of your code to control what kind of error handling happens where.

Now you know how to deal with I/O exceptions! Throwing exceptions from pure code and dealing with 
them hasn't been covered here, mainly because, like we said, Haskell offers much better ways to 
indicate errors than reverting to I/O to catch them. Even when glueing together I/O actions that 
might fail, I prefer to have their type be something like [code]IO (Either a b)[/code], meaning that 
they're normal I/O actions but the result that they yield when performed is of type 
[code]Either a b[/code], meaning it's either [code]Left a[/code] or [code]Right b[/code].
