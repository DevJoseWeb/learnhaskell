title: O tipo de classe Monad

text: Assim como functors tem o tipo de classe [code]Functor[/code] e applicative functors tem o o tipo de classe [code]Applicative[/code], monads tem seu proprio tipo de classe: [code]Monad[/code]! Wow, quem teria pensado? Isso é o tipo de classe que se parece com: 

Vamos começar com a primeira linha. Ela diz: [code]class Monad m where[/code]. Mas espere, nós nao dizemos que monads são apenas reforços de applicative functors? Não deveria haver uma restricoe de classe ao longo das linhas de [code]class (Applicative m) = &gt; Monad m where[/code] assim que o tipo tem que ser primeiro um applicative functor antes de ser produzido um monad? Bem, não deveria, mas quando Haskell foi criado, não tinha ocorrido ser uma boa opção para Haskell. Mas com certeza, cada monad e um applicative functor, mesmo se a declaração não dizer isso.

A primeira função que o tipo de classe [code]Monad[/code] define é [code]return[/code]. É o mesmo que [code]pure[/code], somente com um nome diferente. Esse tipo é [code](Monad m) =&gt; a -&gt; m a[/code]. É preciso um valor e coloca ele em um contexo padrao mínimo que ainda mantém esse valor. Em outras palavras, é preciso alguma coisa para envolver ele em um monad. Ele sempre faz a mesma coisa com a função [code]pure[/code] para o tipo de classe [code]Applicative[/code], o que significa que já estamos familiarizados com [code]return[/code]. Nós já usamos [code]return[/code] quando fizemos I/O. Usamos ele para levar um valor e fazer uma ação ficticia de I/O  que não faz nada mas produziu um valor. Para [code]Maybe[/code] ele cria um valor e envolver ele e um [code]Just[/code].

Apenas um lembrete: [code]return[/code] não tem nada a ver com [code]return[/code] que é usado na maioria das outras linguagens. Ele não termina a execução da função ou qualquer coisa assim, ele apenas tem um valor normal e pegar ele em um contexto.

A próxima função é [code]&gt;&gt;=[/code], ou bind. É como aplicação de função, só que em vez de ter um valor normal e alimertar ele para uma uma função normal, ele tem um valor monadic (ou seja, um valor com um contexto) e alimenta ele para uma função que recebe um valor normal, mas retorna um valor monadic.

Em seguida, temos [code]&gt;&gt;[/code]. Nós não vamos prestar muita atenção nisso agora porque ele vem com uma implemetação padão e nos paricamente nunca implementamos ao criar instancias de monads.

A última função do tipo de classe [code]Monad[/code] é [code]fail[/code]. Nós nunca usamos ela explicitamente em nosso código. Em vez disso, ela é usada por Haskell para permitir falhas em um contrutor semântico espcial para monads que iremos conhecer depois. Nós não precisamos nós peocupar com [code]fail[/code] por hora.

Agora que nós sabemos que o tipo de classe [code]Monad[/code] parece, vamos dar uma olhada em como [code]Maybe[/code] é uma instancia de [code]Monad[/code]! [code]return[/code] é o mesmo que [code]pure[/code], assim não exige inteligência. Nos fazemos o mesmo que fizemos no tipo de classe [code]Applicative[/code] e envolvemos ele em um [code]Just[/code].

The [code]&gt;&gt;=[/code] function is the same as our [code]applyMaybe[/code]. When feeding the [code]Maybe a[/code] to our function, we keep in mind the context and return a [code]Nothing[/code] if the value on the left is [code]Nothing[/code] because if there's no value then there's no way to apply our function to it. If it's a [code]Just[/code] we take what's inside and apply [code]f[/code] to it.

We can play around with [code]Maybe[/code] as a monad:

Nothing new or exciting on the first line since we already used [code]pure[/code] with [code]Maybe[/code] and we know that [code]return[/code] is just [code]pure[/code] with a different name. The next two lines showcase [code]&gt;&gt;=[/code] a bit more.

Notice how when we fed [code]Just 9[/code] to the function [code]\x -&gt; return (x*10)[/code], the [code]x[/code] took on the value [code]9[/code] inside the function. It seems as though we were able to extract the value from a [code]Maybe[/code] without pattern-matching. And we still didn't lose the context of our [code]Maybe[/code] value, because when it's [code]Nothing[/code], the result of using [code]&gt;&gt;=[/code] will be [code]Nothing[/code] as well.