title: Ande na linha

text: Agora que sabemos como alimentar um valor [code]Maybe a[/code] para uma função do tipo [code]a -&gt; Maybe b[/code], tendo em vista o contexto de uma possível falha, vamos ver como podemos usar [code]&gt;&gt;=[/code] várias vezes para lidar com cálculos de vários valores de [code]Maybe a[/code].

Pierre decidiu fazer uma pausa em seu trabalho na fazenda de peixes e tentar caminhar em uma corda banda. Isso não é ruim para ela, mas ele tem um problema: pássaros mantem seu pouso em ponto de equilíbrio! Elas vêm e descansam um pouco, batem um papo com seus amigos pássaros e depois decolam a procura de migalhas de pão. Isso não o incomodaria tanto ele se o número de aves no lado esquerdo do bastão era sempre igual ao número de aves no lado direito. Mas às vezes, todos os pássaros decidem que eles gostam de um lado e assim ele desiquilibra-se, o resultado é uma queda embaraçosa para Pierre (ele está usando uma rede de segurança).

Digamos que ele mantém o seu equilíbrio, se a diferença do número de pássaros do lado esquerdo do bastão e o número de pássaros do lado direito do bastão está entre de três. Assim, se tem um passado do lado direito e quatro pássaros do lado esquerdo, ele está em equilibrio, Mas se um quinto pássaro pousa no lado esquerdo, ele perde o equilíbrio e leva um tombo.

Vamos simular pássaros pousando e voando longe do bastão e ver se Pierre ainda está nele depois de um determinado número de pássaros chegando e partindo. Por exemplo, queremos ver o que acontece com Pierre se o primeiro pássaro chega no lado esquerdo, em seguida, quatro pássaros ocupam o lado direito e depois o pássaro que estava no lado esquerdo decide voar para longe.

Podemos representar o bastão com um simples par de números inteiros. O primeiro componente irá significar o número de aves no lado esquerdo e o segundo componente do número de aves no lado direito:

Primeiro criamos um tipo sinônimo para [code]Int[/code], chamados de [code]Birds[/code], porque estamos usando números inteiros para representar quantos pássaros existem. Em seguida criamos um tipo sinônimo de [code](Birds,Birds)[/code] e chamamos ele de [code]Pole[/code] (para não ser confundido com uma pessoa de ascendência polonesa).

Em seguida, que tal criar uma função que recebe um número de passados e pousa eles em um lado do bastão. Aqui estão as funções:

Coisa muito simples. Vamos testa-los:

Para fazer os pássaros voarem para longe nos apenas temos um número negativo de passados pousando em um lado. Porque pousar um pássaro em [code]Pole[/code] retona um [code]Pole[/code], podemos encadear a aplicação de [code]landLeft[/code] e [code]landRight[/code]:

Quando aplicamos a função [code]landLeft 1[/code] para [code](0,0)[/code] temos [code](1,0)[/code]. Em seguida, pousamos um pássaro do lado direito, resultado em [code](1,1)[/code]. Finalmente dois pássaros pousam no lado esquerdo, resultando em [code](3,1)[/code]. Nós aplicamos uma função primeiro para escrever, em seguida, o seu parâmetro, mas aqui seria melhor se o bastão for o primeiro e depois a função de pouso, Se fizermos uma função como essa:

Podemos primeiro aplicar as funções e escrever parâmetro em seguida da função.

Assim usando isso, podemos repetidamente pousar pássaros no bastão de modo mais legível:

Muito legal! Este exemplo é equivalente ao anterior, onde pousamos repetidamente os pássaros no bastão, porém é mais legível. Aqui, está mais obvio que iniciar com [code](0,0)[/code] e depois pousar um passado na esquerda, depois um na direita e finalmente dois a esquerda.

Até agora está bom, mas o que acontece se 10 pássaros pousam em um lado?

10 pássaros no lado esquerdo e somente 3 no lado direito? Isso com certeza vai fazer o pobre Pierre cair no ar! Isso é bastante obvio aqui, mas o que ocorre ser temos uma sequência de pousos como este:

Podemos pensar que está tudo certo, mas se você seguir os passos até aqui, vai ver que no momento existem 4 pássaros do lado direito e nenhum passado do lado esquerdo! Para corrigir isso, temos que ter outro olhar em nossas funções [code]landLeft[/code] e [code]landRight[/code]. Pelo que percebemos, queremos que essas funções possam falhar. Ou seja, queremos que elas retornem um novo bastão se o equilíbrio está certo, mas não conseguem se os pássaros pousar de forma desequilibrada. E o que é a melhor maneira de adicionar um contexto de falha de valor do que usar [code]Maybe[/code]! Vamos refazer essa função:

Em vez de retornar um [code]Pole[/code] esta função agora retorna um [code]Maybe Pole[/code]. Ela ainda tem o número de pássaros do antigo bastão como antes, mas em seguida ela verifica se o pouso de muitos pássaros no bastão deixaria Pierre em desequilíbrio. Usamos guardas para verificar se a diferença entre o número de pássaros e o novo bastão é menor que 4. Se for, evolvemos o novo bastão em um [code]Just[/code] e retornamos ele. Se não for, nos retornamos um [code]Nothing[/code], indicando falha.

Vamos dar esse bebes uma vez:

Meu caro! Quando pousamos pássaros sem deixar Pierre em desequilíbrio, pegamos um novo bastão envolvido em um [code]Just[/code]. Mas quando muito mais pássaros estão em um lado do bastão, temos um [code]Nothing[/code]. Isso é legal, mas parece ter perdido a habilidade de repetir o pouso de pássaros no bastão. Nós não podemos mais fazer [code]landLeft 1 (landRight 1 (0,0))[/code] porque quando aplicamos [code]landRight 1[/code] para [code](0,0)[/code], nos não temos um [code]Pole[/code], mas um [code]Maybe Pole[/code]. [code]landLeft 1[/code] leva um [code]Pole[/code] e não um [code]Maybe Pole[/code].

Precisamos de uma maneira de ter um [code]Maybe Pole[/code] e alimentar isso para uma função que leva um [code]Pole[/code] e retornar um [code]Maybe Pole[/code]. Felizmente, temos [code]&gt;&gt;=[/code], que faz exatamente isso para [code]Maybe[/code]. Vamos dar uma olhada:

Relembre, [code]landLeft 2[/code] tem um tipo de [code]Pole -&gt; Maybe Pole[/code]. Nos não poderíamos simplesmente alimente este [code]Maybe Pole[/code] que é um resultado de [code]landRight 1 (0,0)[/code],  assim nós usamos [code]&gt;&gt;=[/code] para dar a esse valor com um contexto a [code]landLeft 2[/code].[code]&gt;&gt;=[/code] de fato, permitem tratar o valor [code]Maybe[/code] como um valor com contexto porque se alimentarmos um [code]Nothing[/code] dentro de [code]landLeft 2[/code], o resultado é [code]Nothing[/code] e a falha é propagada:

Com isso, podemos agora encadear pousos que podem falhar porque [code]&gt;&gt;=[/code] nos permite alimentar um valor monadic para uma função que leva um valor normal.

Aqui está a sequência de pousos dos pássaros:

No início, usamos [code]return[/code] para ter um bastão e envolver ele em um [code]Just[/code]. Poderíamos simplesmente ter aplicado [code]landRight 2[/code] para [code](0,0)[/code], isso seria o mesmo, mas desta forma podemos ser mais consistentes utilizando [code]&gt;&gt;=[/code] para todas as funções. [code]Just (0,0)[/code] é alimentado para [code]landRight 2[/code], resultando em [code]Just (0,2)[/code]. Isso, por sua vez, é alimentado para [code]landLeft 2[/code], resultando em [code]Just (2,2)[/code], e assim por diante.

Lembre-se esse no exemplo de antes introduzimos falha dentro da rotina de Pierre:

Isso não simula muito bem sua interação com os pássaros, porque no meio há um desequilíbrio, mas o resultado não reflete isso. Mas vamos ver agora que usamos aplicações monadic ([code]&gt;&gt;=[/code]) em vez aplicações normais:

Incrível. O resultado final representa uma falha, que é o que nós esperávamos. Vamos ver como este resultado foi obtido. Primeiro, [code]return[/code] envia [code](0,0)[/code] dentro do contexto padrão, tornando-se um [code]Just (0,0)[/code]. Em seguida, ocorre [code]Just (0,0) &gt;&gt;= landLeft 1[/code] . Uma vez que o [code]Just (0,0)[/code] é um valor [code]Just[/code], [code]landLeft 1[/code] é aplicado para [code](0,0)[/code], resultando em um [code]Just (1,0)[/code], porque os pássaros ainda estão relativamente em equilíbrio. Em seguida, ocorre [code]Just (1,0) &gt;&gt;= landRight 4[/code], é o resultado é [code]Just (1,4)[/code] com o equilíbrio dos pássaros ainda intacto, embora apenas um pouco. [code]Just (1,4)[/code] é alimentado para [code]landLeft (-1)[/code]. Isto significa que ocorre [code]landLeft (-1) (1,4)[/code]. Agora por causa da forma como [code]landLeft[/code] funciona, isso resulta em um [code]Nothing[/code], porque o bastão resultante é o equilíbrio. Agora que temos um [code]Nothing[/code], ele é alimentado para [code]landRight (-2)[/code], mas porque é um [code]Nothing[/code], o resultado é automaticamente [code]Nothing[/code], como não temos nada para aplicar em [code]landRight (-2)[/code].

Nós não poderíamos ter conseguido isso apenas usando [code]Maybe[/code] como um aplicativo. Se você tentar isso, você vai ficar preso, porque applicative functors não permitem os applicative values interagir uns com os outros muito bem. Eles podem ser usarmos como parâmetros em uma função até usados como um estilo de aplicativo. Os operadores de aplicativos vão buscar esses resultados a alimentá-los para a função de maneira apropriada para cada aplicativo, e depois, colocar o valor do aplicativo final junto, mas não são muito interativos entre si. Aqui, porém, cada passo é baseado no resultado anterior. Em cada pouso, o possível resultado anterior e examinado e o bastão é marcado como equilibrado. Isso determina se o pouso vai ter sucesso ou falha.

Nós podemos também inventar uma função que ignora número atual de pássaros em equilíbrio no bastão apenas fazendo Pierre desequilibrar e cair. Podemos chamar isso de [code]banana[/code]:

Agora podemos encadear isso junto com nossos pássaros pousando. Ele sempre fara nosso caminho falhar, porque ignora o que os passados e sempre retorna uma falha, Confira:

O valor [code]Just (1,0)[/code] é alimentado para [code]banana[/code], mas produz um [code]Nothing[/code], que faz tudo resultar em um [code]Nothing[/code]. Como infeliz!

Em vez de criar funções que ignoram essas entradas e apenas retornam um valor monadic predeterminado, podemos usar a função [code]&gt;&gt;[/code], cuja a implementação padrão é:

Normalmente, passamos algum valor para uma função que ignora seu parâmetro e sempre retorna apenas algum valor predeterminado sempre resultando em no valor pré-determinado. Com monads no entanto, o seu contexto e significado tem que ser considerados. Aqui é como [code]&gt;&gt;[/code] age com [code]Maybe[/code]:

Se você substituir [code]&gt;&gt;[/code] com [code]&gt;&gt;= \_ -&gt;[/code], é fácil ver por que ele age e como ele faz.

Podemos substituir nossa função [code]banana[/code] e encadear com um [code]&gt;&gt;[/code] e, em seguida, um [code]Nothing[/code]:

E ai vamos obviamente falhar!

Também vale a pena dar uma olhada em como seria se não tivéssemos feito uma escolha inteligente para tratar valores [code]Maybe[/code] como valores com um contexto de falha e alimentar ele em funções como fizemos. Aqui uma serie de pássaros pousando, seria algo como como:

Pousamos um passado no lado esquerdo e depois examinados a possibilidade de falha e a possibilidade de sucesso. Em caso de falhar, retornamos um [code]Nothing[/code]. Em caso de sucesso, pousamos os pássaros do lado direito e depois fazemos a mesma coisa novamente. Convertendo essa monstruosidade dentro um encadeamento de aplicações monadic com [code]&gt;&gt;=[/code] é um exemplo clássico de como o monad [code]Maybe[/code] nos poupa tempo quando temos que fazer cálculos sucessivos que são baseados em cálculos que poderão falhar.

Note como o [code]Maybe[/code] e a implementação [code]&gt;&gt;=[/code] caracteriza exatamente esse lógica de ver se o valor é [code]Nothing[/code] e se for isso , retorna imediatamente um [code]Nothing[/code] e se não for, vai para frente com [code]Just[/code].

Nessa seção, abordámos algumas funções e vimos como poderiam funcionar melhor se os valores que eles retornam suportem falha. Transformamos esses valores em valores [code]Maybe[/code] e substituímos aplications functor normais com [code]&gt;&gt;=[/code], temos um mecanismo para tratar falhas livremente, porque [code]&gt;&gt;=[/code] preserva o contexto de um valor para o qual se aplica às funções. Neste caso, o contexto era que nossos valores eram valores com falha e assim quando nos aplicamos funções para esses valores, a possibilidade de falha foi sempre levada em conta.